{"ast":null,"code":"function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { LazyBrush } from \"lazy-brush\";\nimport { Catenary } from \"catenary-curve\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport CoordinateSystem, { IDENTITY } from \"./coordinateSystem\";\nimport drawImage from \"./drawImage\";\nimport { DefaultState } from \"./interactionStateMachine\";\nimport makePassiveEventOption from \"./makePassiveEventOption\";\nfunction midPointBtw(p1, p2) {\n  return {\n    x: p1.x + (p2.x - p1.x) / 2,\n    y: p1.y + (p2.y - p1.y) / 2\n  };\n}\nvar canvasStyle = {\n  display: \"block\",\n  position: \"absolute\"\n}; // The order of these is important: grid > drawing > temp > interface\n\nvar canvasTypes = [\"grid\", \"drawing\", \"temp\", \"interface\"];\nvar dimensionsPropTypes = process.env.NODE_ENV !== \"production\" ? PropTypes.oneOfType([PropTypes.number, PropTypes.string]) : {};\nvar boundsProp = process.env.NODE_ENV !== \"production\" ? PropTypes.shape({\n  min: PropTypes.number.isRequired,\n  max: PropTypes.number.isRequired\n}) : {};\nvar CanvasDraw = /*#__PURE__*/function (_PureComponent) {\n  _inheritsLoose(CanvasDraw, _PureComponent);\n\n  ///// public API /////////////////////////////////////////////////////////////\n  function CanvasDraw(props) {\n    var _this;\n    _this = _PureComponent.call(this, props) || this;\n    _defineProperty(_assertThisInitialized(_this), \"undo\", function () {\n      var lines = [];\n      if (_this.lines.length) {\n        lines = _this.lines.slice(0, -1);\n      } else if (_this.erasedLines.length) {\n        lines = _this.erasedLines.pop();\n      }\n      _this.clearExceptErasedLines();\n      _this.simulateDrawingLines({\n        lines: lines,\n        immediate: true\n      });\n      _this.triggerOnChange();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"eraseAll\", function () {\n      _this.erasedLines.push([].concat(_this.lines));\n      _this.clearExceptErasedLines();\n      _this.triggerOnChange();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"clear\", function () {\n      _this.erasedLines = [];\n      _this.clearExceptErasedLines();\n      _this.resetView();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"resetView\", function () {\n      return _this.coordSystem.resetView();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"setView\", function (view) {\n      return _this.coordSystem.setView(view);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getSaveData\", function () {\n      // Construct and return the stringified saveData object\n      return JSON.stringify({\n        lines: _this.lines,\n        width: _this.props.canvasWidth,\n        height: _this.props.canvasHeight\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getDataURL\", function (fileType, useBgImage, backgroundColour) {\n      // Get a reference to the \"drawing\" layer of the canvas\n      var canvasToExport = _this.canvas.drawing;\n      var context = canvasToExport.getContext(\"2d\"); //cache height and width\n\n      var width = canvasToExport.width;\n      var height = canvasToExport.height; //get the current ImageData for the canvas\n\n      var storedImageData = context.getImageData(0, 0, width, height); //store the current globalCompositeOperation\n\n      var compositeOperation = context.globalCompositeOperation; //set to draw behind current content\n\n      context.globalCompositeOperation = \"destination-over\"; // If \"useBgImage\" has been set to true, this takes precedence over the background colour parameter\n\n      if (useBgImage) {\n        if (!_this.props.imgSrc) return \"Background image source not set\"; // Write the background image\n\n        _this.drawImage();\n      } else if (backgroundColour != null) {\n        //set background color\n        context.fillStyle = backgroundColour; //fill entire canvas with background colour\n\n        context.fillRect(0, 0, width, height);\n      } // If the file type has not been specified, default to PNG\n\n      if (!fileType) fileType = \"png\"; // Export the canvas to data URL\n\n      var imageData = canvasToExport.toDataURL(\"image/\" + fileType); //clear the canvas\n\n      context.clearRect(0, 0, width, height); //restore it with original / cached ImageData\n\n      context.putImageData(storedImageData, 0, 0); //reset the globalCompositeOperation to what it was\n\n      context.globalCompositeOperation = compositeOperation;\n      return imageData;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"loadSaveData\", function (saveData, immediate) {\n      if (immediate === void 0) {\n        immediate = _this.props.immediateLoading;\n      }\n      if (typeof saveData !== \"string\") {\n        throw new Error(\"saveData needs to be of type string!\");\n      }\n      var _JSON$parse = JSON.parse(saveData),\n        lines = _JSON$parse.lines,\n        width = _JSON$parse.width,\n        height = _JSON$parse.height;\n      if (!lines || typeof lines.push !== \"function\") {\n        throw new Error(\"saveData.lines needs to be an array!\");\n      }\n      _this.clear();\n      if (width === _this.props.canvasWidth && height === _this.props.canvasHeight) {\n        _this.simulateDrawingLines({\n          lines: lines,\n          immediate: immediate\n        });\n      } else {\n        // we need to rescale the lines based on saved & current dimensions\n        var scaleX = _this.props.canvasWidth / width;\n        var scaleY = _this.props.canvasHeight / height;\n        var scaleAvg = (scaleX + scaleY) / 2;\n        _this.simulateDrawingLines({\n          lines: lines.map(function (line) {\n            return _extends({}, line, {\n              points: line.points.map(function (p) {\n                return {\n                  x: p.x * scaleX,\n                  y: p.y * scaleY\n                };\n              }),\n              brushRadius: line.brushRadius * scaleAvg\n            });\n          }),\n          immediate: immediate\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"componentWillUnmount\", function () {\n      _this.canvasObserver.unobserve(_this.canvasContainer);\n      _this.canvas[\"interface\"] && _this.canvas[\"interface\"].removeEventListener(\"wheel\", _this.handleWheel);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleWheel\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleMouseWheel(e, _assertThisInitialized(_this));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleDrawStart\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleDrawStart(e, _assertThisInitialized(_this));\n      _this.mouseHasMoved = true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleDrawMove\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleDrawMove(e, _assertThisInitialized(_this));\n      _this.mouseHasMoved = true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleDrawEnd\", function (e) {\n      _this.interactionSM = _this.interactionSM.handleDrawEnd(e, _assertThisInitialized(_this));\n      _this.mouseHasMoved = true;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"applyView\", function () {\n      if (!_this.ctx.drawing) {\n        return;\n      }\n      canvasTypes.map(function (name) {\n        return _this.ctx[name];\n      }).forEach(function (ctx) {\n        _this.clearWindow(ctx);\n        var m = _this.coordSystem.transformMatrix;\n        ctx.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);\n      });\n      if (!_this.deferRedrawOnViewChange) {\n        _this.drawGrid(_this.ctx.grid);\n        _this.redrawImage();\n        _this.loop({\n          once: true\n        });\n        var lines = _this.lines;\n        _this.lines = [];\n        _this.simulateDrawingLines({\n          lines: lines,\n          immediate: true\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleCanvasResize\", function (entries) {\n      var saveData = _this.getSaveData();\n      _this.deferRedrawOnViewChange = true;\n      try {\n        for (var _iterator = _createForOfIteratorHelperLoose(entries), _step; !(_step = _iterator()).done;) {\n          var entry = _step.value;\n          var _entry$contentRect = entry.contentRect,\n            width = _entry$contentRect.width,\n            height = _entry$contentRect.height;\n          _this.setCanvasSize(_this.canvas[\"interface\"], width, height);\n          _this.setCanvasSize(_this.canvas.drawing, width, height);\n          _this.setCanvasSize(_this.canvas.temp, width, height);\n          _this.setCanvasSize(_this.canvas.grid, width, height);\n          _this.coordSystem.documentSize = {\n            width: width,\n            height: height\n          };\n          _this.drawGrid(_this.ctx.grid);\n          _this.drawImage();\n          _this.loop({\n            once: true\n          });\n        }\n        _this.loadSaveData(saveData, true);\n      } finally {\n        _this.deferRedrawOnViewChange = false;\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"clampPointToDocument\", function (point) {\n      if (_this.props.clampLinesToDocument) {\n        return {\n          x: Math.max(Math.min(point.x, _this.props.canvasWidth), 0),\n          y: Math.max(Math.min(point.y, _this.props.canvasHeight), 0)\n        };\n      } else {\n        return point;\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"redrawImage\", function () {\n      _this.image && _this.image.complete && drawImage({\n        ctx: _this.ctx.grid,\n        img: _this.image\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"simulateDrawingLines\", function (_ref) {\n      var lines = _ref.lines,\n        immediate = _ref.immediate;\n      // Simulate live-drawing of the loaded lines\n      // TODO use a generator\n      var curTime = 0;\n      var timeoutGap = immediate ? 0 : _this.props.loadTimeOffset;\n      lines.forEach(function (line) {\n        var points = line.points,\n          brushColor = line.brushColor,\n          brushRadius = line.brushRadius; // Draw all at once if immediate flag is set, instead of using setTimeout\n\n        if (immediate) {\n          // Draw the points\n          _this.drawPoints({\n            points: points,\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          }); // Save line with the drawn points\n\n          _this.points = points;\n          _this.saveLine({\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          });\n          return;\n        } // Use timeout to draw\n\n        var _loop = function _loop(i) {\n          curTime += timeoutGap;\n          window.setTimeout(function () {\n            _this.drawPoints({\n              points: points.slice(0, i + 1),\n              brushColor: brushColor,\n              brushRadius: brushRadius\n            });\n          }, curTime);\n        };\n        for (var i = 1; i < points.length; i++) {\n          _loop(i);\n        }\n        curTime += timeoutGap;\n        window.setTimeout(function () {\n          // Save this line with its props instead of this.props\n          _this.points = points;\n          _this.saveLine({\n            brushColor: brushColor,\n            brushRadius: brushRadius\n          });\n        }, curTime);\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"setCanvasSize\", function (canvas, width, height) {\n      canvas.width = width;\n      canvas.height = height;\n      canvas.style.width = width;\n      canvas.style.height = height;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"drawPoints\", function (_ref2) {\n      var points = _ref2.points,\n        brushColor = _ref2.brushColor,\n        brushRadius = _ref2.brushRadius;\n      _this.ctx.temp.lineJoin = \"round\";\n      _this.ctx.temp.lineCap = \"round\";\n      _this.ctx.temp.strokeStyle = brushColor;\n      _this.clearWindow(_this.ctx.temp);\n      _this.ctx.temp.lineWidth = brushRadius * 2;\n      var p1 = points[0];\n      var p2 = points[1];\n      _this.ctx.temp.moveTo(p2.x, p2.y);\n      _this.ctx.temp.beginPath();\n      for (var i = 1, len = points.length; i < len; i++) {\n        // we pick the point between pi+1 & pi+2 as the\n        // end point and p1 as our control point\n        var midPoint = midPointBtw(p1, p2);\n        _this.ctx.temp.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n        p1 = points[i];\n        p2 = points[i + 1];\n      } // Draw last line as a straight line while\n      // we wait for the next point to be able to calculate\n      // the bezier control point\n\n      _this.ctx.temp.lineTo(p1.x, p1.y);\n      _this.ctx.temp.stroke();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"saveLine\", function (_temp) {\n      var _ref3 = _temp === void 0 ? {} : _temp,\n        brushColor = _ref3.brushColor,\n        brushRadius = _ref3.brushRadius;\n      if (_this.points.length < 2) return; // Save as new line\n\n      _this.lines.push({\n        points: [].concat(_this.points),\n        brushColor: brushColor || _this.props.brushColor,\n        brushRadius: brushRadius || _this.props.brushRadius\n      }); // Reset points array\n\n      _this.points.length = 0; // Copy the line to the drawing canvas\n\n      _this.inClientSpace([_this.ctx.drawing, _this.ctx.temp], function () {\n        _this.ctx.drawing.drawImage(_this.canvas.temp, 0, 0, _this.canvas.drawing.width, _this.canvas.drawing.height);\n      }); // Clear the temporary line-drawing canvas\n\n      _this.clearWindow(_this.ctx.temp);\n      _this.triggerOnChange();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"triggerOnChange\", function () {\n      _this.props.onChange && _this.props.onChange(_assertThisInitialized(_this));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"clearWindow\", function (ctx) {\n      _this.inClientSpace([ctx], function () {\n        return ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"clearExceptErasedLines\", function () {\n      _this.lines = [];\n      _this.valuesChanged = true;\n      _this.clearWindow(_this.ctx.drawing);\n      _this.clearWindow(_this.ctx.temp);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"loop\", function (_temp2) {\n      var _ref4 = _temp2 === void 0 ? {} : _temp2,\n        _ref4$once = _ref4.once,\n        once = _ref4$once === void 0 ? false : _ref4$once;\n      if (_this.mouseHasMoved || _this.valuesChanged) {\n        var pointer = _this.lazy.getPointerCoordinates();\n        var brush = _this.lazy.getBrushCoordinates();\n        _this.drawInterface(_this.ctx[\"interface\"], pointer, brush);\n        _this.mouseHasMoved = false;\n        _this.valuesChanged = false;\n      }\n      if (!once) {\n        window.requestAnimationFrame(function () {\n          _this.loop();\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"inClientSpace\", function (ctxs, action) {\n      ctxs.forEach(function (ctx) {\n        ctx.save();\n        ctx.setTransform(IDENTITY.a, IDENTITY.b, IDENTITY.c, IDENTITY.d, IDENTITY.e, IDENTITY.f);\n      });\n      try {\n        action();\n      } finally {\n        ctxs.forEach(function (ctx) {\n          return ctx.restore();\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"drawImage\", function () {\n      if (!_this.props.imgSrc) return; // Load the image\n\n      _this.image = new Image(); // Prevent SecurityError \"Tainted canvases may not be exported.\" #70\n\n      _this.image.crossOrigin = \"anonymous\"; // Draw the image once loaded\n\n      _this.image.onload = _this.redrawImage;\n      _this.image.src = _this.props.imgSrc;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"drawGrid\", function (ctx) {\n      if (_this.props.hideGrid) return;\n      _this.clearWindow(ctx);\n      var gridSize = 25;\n      var _this$coordSystem$can = _this.coordSystem.canvasBounds,\n        viewMin = _this$coordSystem$can.viewMin,\n        viewMax = _this$coordSystem$can.viewMax;\n      var minx = Math.floor(viewMin.x / gridSize - 1) * gridSize;\n      var miny = Math.floor(viewMin.y / gridSize - 1) * gridSize;\n      var maxx = viewMax.x + gridSize;\n      var maxy = viewMax.y + gridSize;\n      ctx.beginPath();\n      ctx.setLineDash([5, 1]);\n      ctx.setLineDash([]);\n      ctx.strokeStyle = _this.props.gridColor;\n      ctx.lineWidth = _this.props.gridLineWidth;\n      if (!_this.props.hideGridX) {\n        var countX = minx;\n        var gridSizeX = _this.props.gridSizeX;\n        while (countX < maxx) {\n          countX += gridSizeX;\n          ctx.moveTo(countX, miny);\n          ctx.lineTo(countX, maxy);\n        }\n        ctx.stroke();\n      }\n      if (!_this.props.hideGridY) {\n        var countY = miny;\n        var gridSizeY = _this.props.gridSizeY;\n        while (countY < maxy) {\n          countY += gridSizeY;\n          ctx.moveTo(minx, countY);\n          ctx.lineTo(maxx, countY);\n        }\n        ctx.stroke();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"drawInterface\", function (ctx, pointer, brush) {\n      if (_this.props.hideInterface) return;\n      _this.clearWindow(ctx); // Draw brush preview\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.brushColor;\n      ctx.arc(brush.x, brush.y, _this.props.brushRadius, 0, Math.PI * 2, true);\n      ctx.fill(); // Draw mouse point (the one directly at the cursor)\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.catenaryColor;\n      ctx.arc(pointer.x, pointer.y, 4, 0, Math.PI * 2, true);\n      ctx.fill(); // Draw catenary\n\n      if (_this.lazy.isEnabled()) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.lineCap = \"round\";\n        ctx.setLineDash([2, 4]);\n        ctx.strokeStyle = _this.props.catenaryColor;\n        _this.catenary.drawToCanvas(_this.ctx[\"interface\"], brush, pointer, _this.chainLength);\n        ctx.stroke();\n      } // Draw brush point (the one in the middle of the brush preview)\n\n      ctx.beginPath();\n      ctx.fillStyle = _this.props.catenaryColor;\n      ctx.arc(brush.x, brush.y, 2, 0, Math.PI * 2, true);\n      ctx.fill();\n    });\n    _this.canvas = {};\n    _this.ctx = {};\n    _this.catenary = new Catenary();\n    _this.points = [];\n    _this.lines = [];\n    _this.erasedLines = [];\n    _this.mouseHasMoved = true;\n    _this.valuesChanged = true;\n    _this.isDrawing = false;\n    _this.isPressing = false;\n    _this.deferRedrawOnViewChange = false;\n    _this.interactionSM = new DefaultState();\n    _this.coordSystem = new CoordinateSystem({\n      scaleExtents: props.zoomExtents,\n      documentSize: {\n        width: props.canvasWidth,\n        height: props.canvasHeight\n      }\n    });\n    _this.coordSystem.attachViewChangeListener(_this.applyView.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  var _proto = CanvasDraw.prototype;\n\n  ///// private API ////////////////////////////////////////////////////////////\n  ///// React Lifecycle\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n    this.lazy = new LazyBrush({\n      radius: this.props.lazyRadius * window.devicePixelRatio,\n      enabled: true,\n      initialPoint: {\n        x: window.innerWidth / 2,\n        y: window.innerHeight / 2\n      }\n    });\n    this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n    this.canvasObserver = new ResizeObserver(function (entries, observer) {\n      return _this2.handleCanvasResize(entries, observer);\n    });\n    this.canvasObserver.observe(this.canvasContainer);\n    this.drawImage();\n    this.loop();\n    window.setTimeout(function () {\n      var initX = window.innerWidth / 2;\n      var initY = window.innerHeight / 2;\n      _this2.lazy.update({\n        x: initX - _this2.chainLength / 4,\n        y: initY\n      }, {\n        both: true\n      });\n      _this2.lazy.update({\n        x: initX + _this2.chainLength / 4,\n        y: initY\n      }, {\n        both: false\n      });\n      _this2.mouseHasMoved = true;\n      _this2.valuesChanged = true;\n      _this2.clearExceptErasedLines(); // Load saveData from prop if it exists\n\n      if (_this2.props.saveData) {\n        _this2.loadSaveData(_this2.props.saveData);\n      }\n    }, 100); // Attach our wheel event listener here instead of in the render so that we can specify a non-passive listener.\n    // This is necessary to prevent the default event action on chrome.\n    // https://github.com/facebook/react/issues/14856\n\n    this.canvas[\"interface\"] && this.canvas[\"interface\"].addEventListener(\"wheel\", this.handleWheel, makePassiveEventOption());\n  };\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (prevProps.lazyRadius !== this.props.lazyRadius) {\n      // Set new lazyRadius values\n      this.chainLength = this.props.lazyRadius * window.devicePixelRatio;\n      this.lazy.setRadius(this.props.lazyRadius * window.devicePixelRatio);\n    }\n    if (prevProps.saveData !== this.props.saveData) {\n      this.loadSaveData(this.props.saveData);\n    }\n    if (JSON.stringify(prevProps) !== JSON.stringify(this.props)) {\n      // Signal this.loop function that values changed\n      this.valuesChanged = true;\n    }\n    this.coordSystem.scaleExtents = this.props.zoomExtents;\n    if (!this.props.enablePanAndZoom) {\n      this.coordSystem.resetView();\n    }\n    if (prevProps.imgSrc !== this.props.imgSrc) {\n      this.drawImage();\n    }\n  };\n  _proto.render = function render() {\n    var _this3 = this;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: this.props.className,\n      style: _extends({\n        display: \"block\",\n        background: this.props.backgroundColor,\n        touchAction: \"none\",\n        width: this.props.canvasWidth,\n        height: this.props.canvasHeight\n      }, this.props.style),\n      ref: function ref(container) {\n        if (container) {\n          _this3.canvasContainer = container;\n        }\n      }\n    }, canvasTypes.map(function (name) {\n      var isInterface = name === \"interface\";\n      return /*#__PURE__*/React.createElement(\"canvas\", {\n        key: name,\n        ref: function ref(canvas) {\n          if (canvas) {\n            _this3.canvas[name] = canvas;\n            _this3.ctx[name] = canvas.getContext(\"2d\");\n            if (isInterface) {\n              _this3.coordSystem.canvas = canvas;\n            }\n          }\n        },\n        style: _extends({}, canvasStyle),\n        onMouseDown: isInterface ? _this3.handleDrawStart : undefined,\n        onMouseMove: isInterface ? _this3.handleDrawMove : undefined,\n        onMouseUp: isInterface ? _this3.handleDrawEnd : undefined,\n        onMouseOut: isInterface ? _this3.handleDrawEnd : undefined,\n        onTouchStart: isInterface ? _this3.handleDrawStart : undefined,\n        onTouchMove: isInterface ? _this3.handleDrawMove : undefined,\n        onTouchEnd: isInterface ? _this3.handleDrawEnd : undefined,\n        onTouchCancel: isInterface ? _this3.handleDrawEnd : undefined\n      });\n    }));\n  } ///// Event Handlers\n  ;\n  return CanvasDraw;\n}(PureComponent);\n_defineProperty(CanvasDraw, \"defaultProps\", {\n  onChange: null,\n  loadTimeOffset: 5,\n  lazyRadius: 12,\n  brushRadius: 10,\n  brushColor: \"#444\",\n  catenaryColor: \"#0a0302\",\n  gridColor: \"rgba(150,150,150,0.17)\",\n  backgroundColor: \"#FFF\",\n  hideGrid: false,\n  canvasWidth: 400,\n  canvasHeight: 400,\n  disabled: false,\n  imgSrc: \"\",\n  saveData: \"\",\n  immediateLoading: false,\n  hideInterface: false,\n  gridSizeX: 25,\n  gridSizeY: 25,\n  gridLineWidth: 0.5,\n  hideGridX: false,\n  hideGridY: false,\n  enablePanAndZoom: false,\n  mouseZoomFactor: 0.01,\n  zoomExtents: {\n    min: 0.33,\n    max: 3\n  },\n  clampLinesToDocument: false\n});\nexport { CanvasDraw as default };\nCanvasDraw.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  onChange: PropTypes.func,\n  loadTimeOffset: PropTypes.number,\n  lazyRadius: PropTypes.number,\n  brushRadius: PropTypes.number,\n  brushColor: PropTypes.string,\n  catenaryColor: PropTypes.string,\n  gridColor: PropTypes.string,\n  backgroundColor: PropTypes.string,\n  hideGrid: PropTypes.bool,\n  canvasWidth: dimensionsPropTypes,\n  canvasHeight: dimensionsPropTypes,\n  disabled: PropTypes.bool,\n  imgSrc: PropTypes.string,\n  saveData: PropTypes.string,\n  immediateLoading: PropTypes.bool,\n  hideInterface: PropTypes.bool,\n  gridSizeX: PropTypes.number,\n  gridSizeY: PropTypes.number,\n  gridLineWidth: PropTypes.number,\n  hideGridX: PropTypes.bool,\n  hideGridY: PropTypes.bool,\n  enablePanAndZoom: PropTypes.bool,\n  mouseZoomFactor: PropTypes.number,\n  zoomExtents: boundsProp,\n  clampLinesToDocument: PropTypes.bool\n} : {};","map":null,"metadata":{},"sourceType":"module"}