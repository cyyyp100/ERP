{"ast":null,"code":"var _this = this;\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar TOUCH_SLOP = 10;\nvar PINCH_TIMEOUT_MS = 250;\nvar SUPPRESS_SCROLL = function SUPPRESS_SCROLL(e) {\n  // No zooming while drawing, but we'll cancel the scroll event.\n  e.preventDefault();\n  return _this;\n};\n/**\n * The default state for the interaction state machine. Supports zoom and\n * initiating pan and drawing actions.\n */\n\nexport var DefaultState = function DefaultState() {\n  var _this2 = this;\n  _defineProperty(this, \"handleMouseWheel\", function (e, canvasDraw) {\n    var _canvasDraw$props = canvasDraw.props,\n      disabled = _canvasDraw$props.disabled,\n      enablePanAndZoom = _canvasDraw$props.enablePanAndZoom,\n      mouseZoomFactor = _canvasDraw$props.mouseZoomFactor;\n    if (disabled) {\n      return new DisabledState();\n    } else if (enablePanAndZoom && e.ctrlKey) {\n      e.preventDefault();\n      canvasDraw.coordSystem.scaleAtClientPoint(mouseZoomFactor * e.deltaY, clientPointFromEvent(e));\n    }\n    return _this2;\n  });\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return new DisabledState();\n    } else if (e.ctrlKey && canvasDraw.props.enablePanAndZoom) {\n      return new PanState().handleDrawStart(e, canvasDraw);\n    } else {\n      return new WaitForPinchState().handleDrawStart(e, canvasDraw);\n    }\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return new DisabledState();\n    } else {\n      var _viewPointFromEvent = viewPointFromEvent(canvasDraw.coordSystem, e),\n        x = _viewPointFromEvent.x,\n        y = _viewPointFromEvent.y;\n      canvasDraw.lazy.update({\n        x: x,\n        y: y\n      });\n      return _this2;\n    }\n  });\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    return canvasDraw.props.disabled ? new DisabledState() : _this2;\n  });\n};\n;\n/**\n * This state is used as long as the disabled prop is active. It ignores all\n * events and doesn't prevent default actions. The disabled state can only be\n * triggered from the default state (i.e., while no action is actively being\n * performed).\n */\n\nexport var DisabledState = function DisabledState() {\n  var _this3 = this;\n  _defineProperty(this, \"handleMouseWheel\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleMouseWheel(e, canvasDraw);\n    }\n  });\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleDrawStart(e, canvasDraw);\n    }\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleDrawMove(e, canvasDraw);\n    }\n  });\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    if (canvasDraw.props.disabled) {\n      return _this3;\n    } else {\n      return new DefaultState().handleDrawEnd(e, canvasDraw);\n    }\n  });\n};\n/**\n * This state is active as long as the user is panning the image. This state is\n * retained until the pan ceases.\n */\n\nexport var PanState = function PanState() {\n  var _this4 = this;\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    e.preventDefault();\n    _this4.dragStart = clientPointFromEvent(e);\n    _this4.panStart = {\n      x: canvasDraw.coordSystem.x,\n      y: canvasDraw.coordSystem.y\n    };\n    return _this4;\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n    var _clientPointFromEvent = clientPointFromEvent(e),\n      clientX = _clientPointFromEvent.clientX,\n      clientY = _clientPointFromEvent.clientY;\n    var dx = clientX - _this4.dragStart.clientX;\n    var dy = clientY - _this4.dragStart.clientY;\n    canvasDraw.coordSystem.setView({\n      x: _this4.panStart.x + dx,\n      y: _this4.panStart.y + dy\n    });\n    return _this4;\n  });\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n};\n/**\n * This state is active when the user has initiated the drawing action but has\n * not yet created any lines. We use this state to try and detect a second touch\n * event to initiate a pinch-zoom action. We'll give up on that if enough time\n * or movement happens without a second touch.\n */\n\nexport var WaitForPinchState = function WaitForPinchState() {\n  var _this5 = this;\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    var enablePanAndZoom = canvasDraw.props.enablePanAndZoom;\n    e.preventDefault(); // We're going to transition immediately into lazy-drawing mode if\n    // pan-and-zoom isn't enabled or if this event wasn't triggered by a touch.\n\n    if (!e.touches || !e.touches.length || !enablePanAndZoom) {\n      return new DrawingState().handleDrawStart(e, canvasDraw);\n    } // If we already have two touch events, we can move straight into pinch/pan\n\n    if (enablePanAndZoom && e.touches && e.touches.length >= 2) {\n      return new ScaleOrPanState().handleDrawStart(e, canvasDraw);\n    }\n    return _this5.handleDrawMove(e, canvasDraw);\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault(); // If we have two touches, move to pinch/pan (we don't have to recheck\n    // whether zoom is enabled because that happend in draw start).\n\n    if (e.touches && e.touches.length >= 2) {\n      // Use the start draw to handler to transition.\n      return new ScaleOrPanState().handleDrawStart(e, canvasDraw);\n    }\n    var clientPt = clientPointFromEvent(e);\n    _this5.deferredPoints.push(clientPt); // If we've already moved far enough, or if enough time has passed, give up\n    // and switch over to drawing.\n\n    if (new Date().valueOf() - _this5.startTimestamp < PINCH_TIMEOUT_MS) {\n      if (_this5.startClientPoint === null) {\n        _this5.startClientPoint = clientPt;\n      } // Note that we're using \"manhattan distance\" rather than computing a\n      // hypotenuse here as a cheap approximation\n\n      var d = Math.abs(clientPt.clientX - _this5.startClientPoint.clientX) + Math.abs(clientPt.clientY - _this5.startClientPoint.clientY);\n      if (d < TOUCH_SLOP) {\n        // We're not ready to give up yet.\n        return _this5;\n      }\n    } // Okay, give up and start drawing.\n\n    return _this5.issueDeferredPoints(canvasDraw);\n  });\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    // The user stopped drawing before we decided what to do. Just treat this as\n    // if they were drawing all along.\n    return _this5.issueDeferredPoints(canvasDraw).handleDrawEnd(e, canvasDraw);\n  });\n  _defineProperty(this, \"issueDeferredPoints\", function (canvasDraw) {\n    // Time to give up. Play our deferred points out to the drawing state.\n    // The first point will have been a start draw.\n    var nextState = new DrawingState();\n    for (var i = 0; i < _this5.deferredPoints.length; i++) {\n      var deferredPt = _this5.deferredPoints[i];\n      var syntheticEvt = new SyntheticEvent(deferredPt);\n      var func = i === 0 ? nextState.handleDrawStart : nextState.handleDrawMove;\n      nextState = func(syntheticEvt, canvasDraw);\n    }\n    return nextState;\n  });\n  this.startClientPoint = null;\n  this.startTimestamp = new Date().valueOf();\n  this.deferredPoints = [];\n};\n/**\n * This state is active when the user has added at least two touch points but we\n * don't yet know if they intend to pan or zoom.\n */\n\nexport var ScaleOrPanState = function ScaleOrPanState() {\n  var _this6 = this;\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    e.preventDefault();\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n    _this6.start = _this6.getTouchMetrics(e);\n    _this6.panStart = {\n      x: canvasDraw.coordSystem.x,\n      y: canvasDraw.coordSystem.y\n    };\n    _this6.scaleStart = canvasDraw.coordSystem.scale;\n    return _this6;\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n    var _this6$recentMetrics = _this6.recentMetrics = _this6.getTouchMetrics(e),\n      centroid = _this6$recentMetrics.centroid,\n      distance = _this6$recentMetrics.distance; // Switch to scaling?\n\n    var dd = Math.abs(distance - _this6.start.distance);\n    if (dd >= TOUCH_SLOP) {\n      return new TouchScaleState(_this6).handleDrawMove(e, canvasDraw);\n    } // Switch to panning?\n\n    var dx = centroid.clientX - _this6.start.centroid.clientX;\n    var dy = centroid.clientY - _this6.start.centroid.clientY;\n    var dc = Math.abs(dx) + Math.abs(dy);\n    if (dc >= TOUCH_SLOP) {\n      return new TouchPanState(_this6).handleDrawMove(e, canvasDraw);\n    } // Not enough movement yet\n\n    return _this6;\n  });\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n  _defineProperty(this, \"getTouchMetrics\", function (e) {\n    var _clientPointFromEvent2 = clientPointFromEvent(e.touches[0]),\n      t1x = _clientPointFromEvent2.clientX,\n      t1y = _clientPointFromEvent2.clientY;\n    var _clientPointFromEvent3 = clientPointFromEvent(e.touches[1]),\n      t2x = _clientPointFromEvent3.clientX,\n      t2y = _clientPointFromEvent3.clientY;\n    var dx = t2x - t1x;\n    var dy = t2y - t1y;\n    return {\n      t1: {\n        clientX: t1x,\n        clientY: t1y\n      },\n      t2: {\n        clientX: t2x,\n        clientY: t2y\n      },\n      distance: Math.sqrt(dx * dx + dy * dy),\n      centroid: {\n        clientX: (t1x + t2x) / 2.0,\n        clientY: (t1y + t2y) / 2.0\n      }\n    };\n  });\n};\n/**\n * The user is actively using touch gestures to pan the image.\n */\n\nexport var TouchPanState = function TouchPanState(scaleOrPanState) {\n  var _this7 = this;\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n  _defineProperty(this, \"handleDrawStart\", function () {\n    return _this7;\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n    var ref = _this7.scaleOrPanState;\n    var _ref$recentMetrics = ref.recentMetrics = ref.getTouchMetrics(e),\n      centroid = _ref$recentMetrics.centroid,\n      distance = _ref$recentMetrics.distance;\n    var dx = centroid.clientX - ref.start.centroid.clientX;\n    var dy = centroid.clientY - ref.start.centroid.clientY;\n    canvasDraw.setView({\n      x: ref.panStart.x + dx,\n      y: ref.panStart.y + dy\n    });\n    return _this7;\n  });\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n  this.scaleOrPanState = scaleOrPanState;\n};\n/**\n * The user is actively using touch gestures to scale the drawing.\n */\n\nexport var TouchScaleState = function TouchScaleState(scaleOrPanState) {\n  var _this8 = this;\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n  _defineProperty(this, \"handleDrawStart\", function () {\n    return _this8;\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n    if (!e.touches || e.touches.length < 2) {\n      return new DefaultState();\n    }\n    var ref = _this8.scaleOrPanState;\n    var _ref$recentMetrics2 = ref.recentMetrics = ref.getTouchMetrics(e),\n      centroid = _ref$recentMetrics2.centroid,\n      distance = _ref$recentMetrics2.distance;\n    var targetScale = ref.scaleStart * (distance / ref.start.distance);\n    var dScale = targetScale - canvasDraw.coordSystem.scale;\n    canvasDraw.coordSystem.scaleAtClientPoint(dScale, centroid);\n    return _this8;\n  });\n  _defineProperty(this, \"handleDrawEnd\", function () {\n    return new DefaultState();\n  });\n  this.scaleOrPanState = scaleOrPanState;\n};\n/**\n * This state is active when the user is drawing.\n */\n\nexport var DrawingState = function DrawingState() {\n  var _this9 = this;\n  _defineProperty(this, \"handleMouseWheel\", SUPPRESS_SCROLL.bind(this));\n  _defineProperty(this, \"handleDrawStart\", function (e, canvasDraw) {\n    e.preventDefault();\n    if (e.touches && e.touches.length) {\n      // on touch, set catenary position to touch pos\n      var _viewPointFromEvent2 = viewPointFromEvent(canvasDraw.coordSystem, e),\n        x = _viewPointFromEvent2.x,\n        y = _viewPointFromEvent2.y;\n      canvasDraw.lazy.update({\n        x: x,\n        y: y\n      }, {\n        both: true\n      });\n    }\n    return _this9.handleDrawMove(e, canvasDraw);\n  });\n  _defineProperty(this, \"handleDrawMove\", function (e, canvasDraw) {\n    e.preventDefault();\n    var _viewPointFromEvent3 = viewPointFromEvent(canvasDraw.coordSystem, e),\n      x = _viewPointFromEvent3.x,\n      y = _viewPointFromEvent3.y;\n    canvasDraw.lazy.update({\n      x: x,\n      y: y\n    });\n    var isDisabled = !canvasDraw.lazy.isEnabled();\n    if (!_this9.isDrawing || isDisabled) {\n      // Start drawing and add point\n      canvasDraw.points.push(canvasDraw.clampPointToDocument(canvasDraw.lazy.brush.toObject()));\n      _this9.isDrawing = true;\n    } // Add new point\n\n    canvasDraw.points.push(canvasDraw.clampPointToDocument(canvasDraw.lazy.brush.toObject())); // Draw current points\n\n    canvasDraw.drawPoints({\n      points: canvasDraw.points,\n      brushColor: canvasDraw.props.brushColor,\n      brushRadius: canvasDraw.props.brushRadius\n    });\n    return _this9;\n  });\n  _defineProperty(this, \"handleDrawEnd\", function (e, canvasDraw) {\n    e.preventDefault(); // Draw to this end pos\n\n    _this9.handleDrawMove(e, canvasDraw);\n    canvasDraw.saveLine();\n    return new DefaultState();\n  });\n  this.isDrawing = false;\n};\nexport var SyntheticEvent = function SyntheticEvent(_ref) {\n  var clientX = _ref.clientX,\n    clientY = _ref.clientY;\n  _defineProperty(this, \"preventDefault\", function () {});\n  this.clientX = clientX;\n  this.clientY = clientY;\n  this.touches = [{\n    clientX: clientX,\n    clientY: clientY\n  }];\n};\nexport function clientPointFromEvent(e) {\n  // use cursor pos as default\n  var clientX = e.clientX;\n  var clientY = e.clientY; // use first touch if available\n\n  if (e.changedTouches && e.changedTouches.length > 0) {\n    clientX = e.changedTouches[0].clientX;\n    clientY = e.changedTouches[0].clientY;\n  }\n  return {\n    clientX: clientX,\n    clientY: clientY\n  };\n}\nexport function viewPointFromEvent(coordSystem, e) {\n  return coordSystem.clientPointToViewPoint(clientPointFromEvent(e));\n}","map":null,"metadata":{},"sourceType":"module"}